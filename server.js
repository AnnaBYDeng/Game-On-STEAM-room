// Copyright (c) 2016 IBM Corp. All rights reserved.
// Use of this source code is governed by the Apache License,
// Version 2.0, a copy of which can be found in the LICENSE file.

var WebSocketServer = require('websocket').server;

var http = require('http');
var serveStatic = require('serve-static')
var finalhandler = require('finalhandler')
var winston = require('winston');

//Ws functions
var sendUnknownType = require('./src/room/sendUnknownType.js');
var prepareChatMessage = require('./src/room/prepareChatMessage.js');
var prepareGoodbyeMessage = require('./src/room/prepareGoodbyeMessage.js');
var sendInventory = require('./src/room/sendInventory.js');
var sendExamine = require('./src/room/sendExamine.js');
var parseGoCommand = require('./src/room/parseGoCommand.js');
var sendUnknownCommand = require('./src/room/sendUnknownCommand.js');
var sendRoomChange = require("./src/room/sendRoomChange.js");
var sendScience = require("./src/room/sendScience.js");

// Room Details
// Your room's name
var theRoomName = (process.env.ROOM_NAME || '');
var fullName = (process.env.FULL_NAME || '');
var description = (process.env.DESCRIPTION || 'This room is filled with little JavaScripts running around everywhere and a monster');

// The environment for the running CF application
var vcapApplication = (process.env.VCAP_APPLICATION || '{}');

// Automatically retrieves the port of your CF
var port = (JSON.parse(vcapApplication).port || 3000);
var appUris = (JSON.parse(vcapApplication).application_uris || ['localhost:'+port]);
var endpointip = appUris[0];

//Initialize users array
var users = [];

/*array of room constants to be used for STEAM. 
Each room must have the following:
-an index that represents the room name
-a description for when the room is entered or examined
-a help message that lists the commands and objects in the room.
*/
var rooms = [];

rooms["SCIENCE"] = []
rooms["SCIENCE"].description = "Before you is a dimly lit room with materials scattered around the edges. In the center, there is a bowl of water " +
"with a small pit beneath it. The materials include: PAPER, GAS, WOOD, and COAL." 
rooms["SCIENCE"].help = ""
rooms["TECHNOLOGY"] = []
rooms["TECHNOLOGY"].description = "The room you are in is dimly lit with a small touch screen console glowing in the middle. There are 4 buttons marked: " +
"ENGINE, HORN, LIGHTS, and BREAKS. "
rooms["ENGINEERING"] = []
rooms["ENGINEERING"].description = "This room contains various parts throughout it. Also, 4 empty tiles in the middle of it. The parts include: " 
rooms["ART"] = []
rooms["ART"].description = "There are buckets of paint all throughout the room. In the center of the room, there is something that looks like a mixer in the middle as well." 
rooms["MATH"] = []
rooms["MATH"].description = "In this location, you found a huge heap of metal piled high and marked with a price. In front of you lies some paper, with some basic equations on them"
var logger = new winston.Logger({
    level: 'debug',
    transports: [
        new(winston.transports.Console)(),
        new(winston.transports.File)({
            filename: './access.log'
        })
    ]
});

function logerror (err) {
  console.error(err.stack || err.toString())
}

// Serve up public folder
var serve = serveStatic('public')

//Serve up static files (index page & supporting CLI-side JS)
var httpServer = http.createServer(function(req, res) {
  if (req.url === '/health') {
      res.writeHead(200);
      res.end("OK");
  } else {
      serve(req, res, finalhandler(req, res, {onerror: logerror}));
  }

}).listen(port);

//Create websocket
var wsServer = new WebSocketServer({
    httpServer: httpServer,
    autoAcceptConnections: false
});

function originIsAllowed(origin) {
    // Logic to determine if this origin is allowed
    // Consider using the secure key generated by Game On! to
    // validate that incoming requests are from Game On!
    // https://gameontext.gitbooks.io/gameon-gitbook/content/microservices/ApplicationSecurity.html#_signed_requests
    return true;
}

wsServer.on('request', function(request) {
    if (!originIsAllowed(request.origin)) {
        // Only accept requests from allowed origins
        request.reject();
        logger.debug("Connection from origin " + request.origin + "rejected.");
        return;
    };
    var conn = request.accept();
    conn.on('message', function(message) {
        if (message.type === 'utf8') {
            var incoming = message.utf8Data;
            logger.debug("RECEIVED: " + incoming)
            var typeEnd = incoming.indexOf(',')
            var targetEnd = incoming.indexOf(',', typeEnd + 1)

            var messageType = incoming.substr(0, typeEnd)
            console.log("MessageType is " + messageType);
            var target = incoming.substr(typeEnd + 1, targetEnd - typeEnd - 1)
            var objectStr = incoming.substr(targetEnd + 1)
            var object = {}
            try {
                object = JSON.parse(objectStr)
            } catch (err) {
                logger.error("Got improper json: " + objectStr)
            }

			//if its this users first time connecting
			if(typeof users[object.username] === 'undefined'){
				users[object.username] = [];
				//initialize new connection
				reset(users[object.username]);
				
			}
			
            logger.info("Parsed a message of type \"" + messageType + "\" sent to target \"" + target + "\".")

            //if (target != theRoomName)
            //  return

            if (messageType === "roomHello") {
                logger.debug("In roomHello")
                sayHello(conn, object.userId, object.username)
            } else if (messageType === "room") {
                if (object.content.indexOf('/') == 0) {
                    parseCommand(conn, object.userId, object.username, object.content)
                } else {
                    logger.info(object.username + " sent chat message \"" + object.content + "\"")
                    broadcast(prepareChatMessage(conn, object.username, object.content));
                }
            } else if (messageType === "roomGoodbye") {
                logger.debug("Announcing that \"" + object.username + "\" has left the room.")
                broadcast(prepareGoodbyeMessage(conn, object.userId, object.username))
            } else {
                sendUnknownType(conn, object.userId, object.username, messageType, logger);
            }
        }
    });
    conn.on("close", function(code, reason) {
            logger.debug("Connection closed.")
    });
});

// Install a special handler to make sure ctrl-c on the command line stops the container
process.on('SIGINT', function() {
    logger.info("The server is exiting");
    wsServer.shutDown();
    process.exit(0);
});

function parseCommand(conn, target, username, content) {
	content = content.toUpperCase();
    if (content.substr(1, 3) == "GO ") {
        parseGoCommand(conn, target, username, content, registration.doors, logger);
    }
    /*else if (content.substr(1, 5) == "exits")
    {
      sendExits(conn, target, username)
    }
	
    else if (content.substr(1, 4) == "help")
    {
      sendHelp(conn, target, username)
    }*/
	else if (content.substr(1, 6) == "ENTER " | content.substr(1, 4) == "EXIT")
    {
      sendRoomChange(conn, target, username, logger, content, users[username], rooms);
    }
    else if (content.substr(1, 7) == "EXAMINE") {
        sendExamine(conn, target, username, logger, users[username]);
    } 
	else if (content.substr(1, 9) == "inventory")
    {
      sendInventory(conn, target, username, logger, users[username]);
    }
	else if (users[username].loc == "SCIENCE")
    {
      sendScience(conn, target, username, logger, content, users[username]);
	  
    }
    else {
        sendUnknownCommand(conn, target, content, logger);
    }
	if(users[username].updateMain = 1){
		users[username].updateMain = 0
		updateMain(users[username])
	}
}

function sayHello(conn, target, username) {
    logger.info("Saying hello to \"" + target + "\"")
    var responseObject = {
        "type": "location",
        "name": theRoomName,
        "fullName": fullName,
        "description": description,
    }

    var sendMessageType = "player"
    var sendTarget = target

    var messageText = sendMessageType + "," +
        sendTarget + "," +
        JSON.stringify(responseObject)

    conn.sendUTF(messageText)

    logger.debug("And announcing that \"" + username + "\" has arrived.")
    var broadcastMessageType = "player"
    var broadcastMessageTarget = "*"
    var broadcastMessageObject = {
        type: "event",
        content: {
            "*": username + " enters the room."
        },
        bookmark: 51
    }
    var broadcastMessage = broadcastMessageType + "," +
        broadcastMessageTarget + "," +
        JSON.stringify(broadcastMessageObject)

    broadcast(broadcastMessage)
}

function broadcast(message) {
    wsServer.connections.forEach(function(conn) {
        conn.sendUTF(message)
    })
}

process.on('uncaughtException', function(err) {
    // handle the error safely
    console.log("UNCAUGHT EXCEPTION! " + err)
})

logger.info("The HTTP server is listening on port " + port)
logger.info("The WebSocket server is listening on port " + port)

var reset = function reset(user){
    //define items array for each connection
	user.items = [];
	//initialize base value for items array
	user.items["Lighter"] = 0
	user.items["Fuel"] = "NONE"
	user.items["Buttons"] = [] 
	user.items["Buttons"]["Engine"] = "Horn"
	user.items["Buttons"]["Horn"] = "Breaks"
	user.items["Buttons"]["Breaks"] = "Lights"
    user.items["Buttons"]["Lights"] = "Engine"
	user.items["Colors"] = []
	user.items["Cost"] = 0
	user.items["Parts"] = []
	user.MAIN = []
    user.MAIN['S'] = '-'
	user.MAIN['T'] = '-'
	user.MAIN['E'] = '-'
	user.MAIN['A'] = '-'
	user.MAIN['M'] = '-'
	user.updateMain = 0
	//tracks current progress in the STEAM room
    user.MAIN.description = ""
	updateMain(user)
	user.loc = "MAIN"
	user.rst = 0;  //reset indicator
}
var updateMain = function updateMain(user){
	user.MAIN.description = "You are in the STEAM MAIN room. Surrounding you are 5 door ways. Each door way has a letter over top of it. The doors are marked S T E A M. The letter will be lit for each door once the challenge in the room is completed. So far, you have "
	+ user.MAIN['S'] 
	+ user.MAIN['T']
	+ user.MAIN['E']
	+ user.MAIN['A']
	+ user.MAIN['M'] + " lit up."
}
